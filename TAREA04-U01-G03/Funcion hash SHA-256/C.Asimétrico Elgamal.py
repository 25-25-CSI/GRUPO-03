# -*- coding: utf-8 -*-
"""Asimetrico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xg4IqLHHbXkjW0saY7rFCjRENQttnkvA
"""

import os

def crear_txt_con_palabras(nombre_archivo, cantidad_palabras, palabra="hola mundo", carpeta="archivos_palabras"):
    if not os.path.exists(carpeta):
        os.makedirs(carpeta)

    contenido = (palabra + " ") * cantidad_palabras
    ruta = os.path.join(carpeta, nombre_archivo)

    with open(ruta, "w", encoding="utf-8") as f:
        f.write(contenido.strip())  # quitar el espacio final

    print(f"[‚úì] Archivo '{ruta}' creado con {cantidad_palabras} palabras.")

crear_txt_con_palabras("Mensaje10.txt", 10)
crear_txt_con_palabras("Mensaje100.txt", 100)
crear_txt_con_palabras("Mensaje1000.txt", 1000)
crear_txt_con_palabras("Mensaje10000.txt", 10000)
crear_txt_con_palabras("Mensaje100000.txt", 100000)
crear_txt_con_palabras("Mensaje1000000.txt", 1000000)
crear_txt_con_palabras("Mensaje10000000.txt", 10000000)

import random
import time
from sympy import mod_inverse, isprime

# --- Generar las claves ElGamal ---
def generar_claves(prime_size=2048):
    while True:
        prime = random.getrandbits(prime_size)
        if isprime(prime):
            break
    generator = random.randint(2, prime - 2)
    private_key = random.randint(2, prime - 2)
    public_key = pow(generator, private_key, prime)
    return (prime, generator, public_key), private_key

# --- Cifrado de un bloque ---
def cifrar_bloque(bloque, clave_publica):
    prime, generator, public_key = clave_publica
    k = random.randint(2, prime - 2)
    a = pow(generator, k, prime)

    numero = int.from_bytes(bloque.encode('utf-8'), 'big')
    if numero >= prime:
        raise ValueError("Bloque demasiado grande para el primo p.")
    b = (numero * pow(public_key, k, prime)) % prime
    return (a, b)

# --- Descifrado de un bloque ---
def descifrar_bloque(cifrado, private_key, prime):
    a, b = cifrado
    shared_secret = pow(a, private_key, prime)
    shared_secret_inv = mod_inverse(shared_secret, prime)
    numero = (b * shared_secret_inv) % prime
    bloque_bytes = numero.to_bytes((numero.bit_length() + 7) // 8, 'big')
    return bloque_bytes.decode('utf-8')

# --- Leer archivo y dividir mensaje en bloques ---
def leer_y_dividir_mensaje(nombre_archivo, tama√±o_bloque=32):
    with open(nombre_archivo, "r", encoding="utf-8") as f:
        contenido = f.read().strip()
    bloques = [contenido[i:i + tama√±o_bloque] for i in range(0, len(contenido), tama√±o_bloque)]
    return bloques

# --- Programa principal ---
start_total = time.perf_counter()

# 1. Leer archivo
start = time.perf_counter()
try:
    bloques = leer_y_dividir_mensaje("/content/archivos_palabras/Mensaje1000000.txt", tama√±o_bloque=32)
except FileNotFoundError:
    print("Error: No se encontr√≥ el archivo 'Mensaje1000000.txt'")
    exit(1)

# Contar caracteres de entrada
mensaje_original = ''.join(bloques)
print(f"[‚úì] Mensaje le√≠do del archivo ({len(bloques)} bloques)")
print(f"üìù N√∫mero de caracteres del mensaje original: {len(mensaje_original)}")
print(f"‚è± Tiempo de lectura: {(time.perf_counter() - start):.6f} segundos\n")

# 2. Generar claves
start = time.perf_counter()
clave_publica, clave_privada = generar_claves()
p, g, y = clave_publica
print("[‚úì] Claves generadas:")
print(f"  Clave p√∫blica (p, g, y):\n  p = {p}\n  g = {g}\n  y = {y}")
print(f"  Clave privada (x): {clave_privada}")
print(f"‚è± Tiempo de generaci√≥n de claves: {(time.perf_counter() - start):.6f} segundos\n")

# 3. Cifrado
start = time.perf_counter()
mensajes_cifrados = []
for bloque in bloques:
    try:
        cifrado = cifrar_bloque(bloque, clave_publica)
        mensajes_cifrados.append(cifrado)
    except ValueError as e:
        print("Error al cifrar:", e)
        exit(1)
print("[‚úì] Cifrado completado.")
print(f"‚è± Tiempo de cifrado: {(time.perf_counter() - start):.6f} segundos\n")

# 4. Descifrado
start = time.perf_counter()
mensaje_descifrado = ""
for cifrado in mensajes_cifrados:
    mensaje_descifrado += descifrar_bloque(cifrado, clave_privada, clave_publica[0])
print("[‚úì] Descifrado completado.")
print(f"üìù N√∫mero de caracteres del mensaje descifrado: {len(mensaje_descifrado)}")
print(f"‚è± Tiempo de descifrado: {(time.perf_counter() - start):.6f} segundos\n")

# Verificaci√≥n de integridad
if mensaje_original == mensaje_descifrado:
    print("‚úÖ El mensaje descifrado coincide con el original.")
else:
    print("‚ùå El mensaje descifrado NO coincide con el original.")

# Tiempo total
print(f"‚è± Tiempo total de ejecuci√≥n: {(time.perf_counter() - start_total):.6f} segundos")